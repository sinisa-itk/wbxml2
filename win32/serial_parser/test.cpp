#define _CRT_SECURE_NO_WARNINGS

#include <wbxml.h>
#include <wbxml_mem.h>

#include <vector>
#include <sstream>
#include <map>
#include <algorithm>
#include <string.h>
#include <stdexcept>
#include <string>


#include <wbxml_parser.h>
#include <wbxml_elt.h>
#include <wbxml_buffers.h>


using std::runtime_error;
using std::string;
using std::vector;
using std::map;



class ParsingContext {
public:

	static void start_document(void *ctx, WBXMLCharsetMIBEnum charset, const WBXMLLangEntry *lang) {
		printf("[start_document] charset=%d language=%d \n", charset, lang->langID);
		//wbxml_charset_get_name(charset, charset_name);
	}
	static void end_document(void *ctx) {
		printf("[end_document] \n");
	}
	static void start_element(void *ctx, WBXMLTag *element, WBXMLAttribute **attrs, WB_BOOL empty) {
		if(element->type == WBXML_VALUE_TOKEN) {
			printf("[start_element] isempty:%d xml-tag-name:%s wbxml-token=0x%X \n", (int)empty, element->u.token->xmlName, (unsigned int) element->u.token->wbxmlToken);
		} else {
			printf("[start_element] isempty:%d literal:%s \n", (int)empty, string((const char*) wbxml_buffer_get_cstr(element->u.literal), wbxml_buffer_len(element->u.literal)).c_str());
		}
	}
	static void end_element(void *ctx, WBXMLTag *element, WB_BOOL empty) {
		if(element->type == WBXML_VALUE_TOKEN) {
			printf("[end_element] isempty:%d xml-tag-name:%s wbxml-token=0x%X \n", (int)empty, element->u.token->xmlName, (unsigned int) element->u.token->wbxmlToken);
		} else {
			printf("[end_element] isempty:%d literal:%s \n", (int)empty, string((const char*) wbxml_buffer_get_cstr(element->u.literal), wbxml_buffer_len(element->u.literal)).c_str());
		}
	}
	static void characters(void *ctx, WB_UTINY *ch, WB_ULONG start, WB_ULONG length) {
		printf("[characters] %s \n", string((char *) (ch + start), length).c_str());
	}
	static void pi(void *ctx, const WB_UTINY *target, WB_UTINY *data) {
		printf("[pi] %s \n");
	}

	static void characters_in_filebuffer(void *ctx, WBXMLBuffer * buffer, WB_ULONG start, WB_ULONG length) {
		char * storage_for_display = new char[length +1];
		printf("[filestored-characters] %s \n", wbxml_buffer_get_entire_string(buffer));
	}

	static const char * allocated_filename_provider(void *ctx) {
		static int _index = 0, len;
		char filename[1024];
		sprintf(filename, "_temp_%d.bin", _index++);
		len = strlen(filename);
		char * ret = new char[len +1];
		memcpy(ret, filename, len);
		ret[len] = 0;
		return (const char *) ret;
	}

	static void free_allocated_filename(void *ctx, const char * allocated) {
		char * _allocated = (char*) allocated;
		delete [] _allocated;
	}

};






void print_xml(const char *xml, int xml_len, string line_prefix = "") {
	enum {
		PX_START,
		PX_START_TAG,
		PX_OPENING_TAG,
		PX_TAG_PARAMS,
		PX_BODY,
		PX_CLOSING_TAG
	};
	int state = PX_START;
	int pos = 0;
	int indents = 0;
	string tag;

	printf("\n%sprint_xml %d", line_prefix.c_str(), xml_len);
	while (pos < xml_len) {
		switch (state) {
		case PX_START:
			if (xml[pos] == '<') {
				state = PX_START_TAG;
			}
			break;
		case PX_START_TAG:
			printf("\n%s", line_prefix.c_str());
			tag = "";
			if (xml[pos] == '/') {
				indents--;
				for (int j = 0; j < indents; j++) {
					printf(" ");
				}
				state = PX_CLOSING_TAG;
			} else {
				for (int j = 0; j < indents; j++) {
					printf(" ");
				}
				indents++;
				state = PX_OPENING_TAG;
			}
			printf("%c", xml[pos - 1]);
			break;
		case PX_OPENING_TAG:
			if (xml[pos] == ' ') {
				state = PX_TAG_PARAMS;
			}
			if (xml[pos] == '>') {
				state = PX_BODY;
			}
			break;
		case PX_TAG_PARAMS:
			if (xml[pos] == '>') {
				state = PX_BODY;
			}
			break;
		case PX_BODY:
			if (xml[pos] == '<') {
				state = PX_START_TAG;
			} else if (xml[pos - 1] == '>') {
				printf("\n%s", line_prefix.c_str());
				for (int j = 0; j <= indents; j++) {
					printf(" ");
				}
			}
			break;
		case PX_CLOSING_TAG:
			if (xml[pos] == ' ') {
				state = PX_TAG_PARAMS;
			}
			if (xml[pos] == '>') {
				state = PX_START;
			}
			break;
		}
		if (state == PX_OPENING_TAG){
			tag.append(xml + pos, 1);
		}
		if (state != PX_START_TAG) {
			if ((tag == "unknown") && (xml[pos] != 'n') && (xml[pos] != '>')) {
				printf("%02x ", (unsigned char)xml[pos]);
			} else {
				printf("%c", xml[pos]);
			}
		}
		pos++;
	}
	printf("\n%s/print_xml\n", line_prefix.c_str());
}

string wbxml2xml(string wbxml) {
	WB_UTINY * xml;
	WB_ULONG   xml_len;
	WBXMLGenXMLParams params;

	params.gen_type = WBXML_GEN_XML_CANONICAL;
	params.lang = WBXML_LANG_AIRSYNC;
	params.indent = 0;
	//params.keep_ignorable_ws = 1;
	params.keep_ignorable_ws = 0;

	WBXMLError retval = wbxml_conv_wbxml2xml_withlen((WB_UTINY *) wbxml.c_str(), wbxml.size(), &xml, &xml_len, &params);
	//	printf("wbxml len: %d, retval = %d, xml_len = %d\n", wbxml.size(), retval, xml_len);
	if (retval != 0) {
		throw runtime_error("wbxml2xml::WBXMLParseError");
	}
	//	print_xml((char*) xml, xml_len, "response:");

	string ret((char*) xml, xml_len);
	wbxml_free(xml);
	return ret;
}

string xml2wbxml(string xml) {
	WB_UTINY * bytes;
	WB_ULONG   size;
	WBXMLGenWBXMLParams params;

	params.wbxml_version = WBXML_VERSION_13;
	//params.wbxml_version = WBXML_VERSION_12;
	//params.keep_ignorable_ws = 1;
	params.keep_ignorable_ws = 0;
	params.use_strtbl = 0;
	params.produce_anonymous = 1;

	//  if isinstance(xml, unicode):
	//  	xml = xml.encode("utf-8")
	//	print_xml((char*) xml.c_str(), xml.size(), "request:");

	WBXMLError retval = wbxml_conv_xml2wbxml_withlen((WB_UTINY *) xml.c_str(), xml.size(), &bytes, &size, &params);
	if (retval != 0) {
		throw runtime_error("xml2wbxml::WBXMLParseError");
	}
	string ret((char*) bytes, size);
	wbxml_free(bytes);
	return ret;
}


int main() {
	int binary_size = 650 ;
	char binary [] = {
		0x03,  0x01,  0x6a,  0x00,  0x00,  0x07,  0x56,  0x4c,  0x03,  0x31,
		0x00,  0x01,  0x52,  0x03,  0x30,  0x30,  0x37,  0x5a,  0x6d,  0x4c,
		0x56,  0x61,  0x43,  0x75,  0x68,  0x6b,  0x65,  0x77,  0x6d,  0x57,
		0x55,  0x64,  0x50,  0x77,  0x4d,  0x39,  0x72,  0x51,  0x3d,  0x3d,
		0x30,  0x30,  0x31,  0x3d,  0x3d,  0x3d,  0x3d,  0x3d,  0x3d,  0x3d,
		0x3d,  0x3d,  0x3d,  0x3d,  0x41,  0x51,  0x45,  0x41,  0x41,  0x41,
		0x41,  0x63,  0x4e,  0x77,  0x73,  0x41,  0x30,  0x41,  0x49,  0x6a,
		0x58,  0x58,  0x41,  0x63,  0x41,  0x3d,  0x3d,  0x3d,  0x00,  0x01,
		0x4e,  0x57,  0x03,  0x39,  0x00,  0x01,  0x4f,  0x48,  0x03,  0x30,
		0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x2d,  0x30,  0x30,
		0x30,  0x30,  0x2d,  0x30,  0x30,  0x30,  0x30,  0x2d,  0x30,  0x30,
		0x30,  0x30,  0x2d,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,
		0x30,  0x30,  0x30,  0x30,  0x31,  0x00,  0x01,  0x49,  0x03,  0x30,
		0x00,  0x01,  0x47,  0x03,  0x49,  0x6e,  0x62,  0x6f,  0x78,  0x00,
		0x01,  0x4a,  0x03,  0x32,  0x00,  0x01,  0x01,  0x4f,  0x48,  0x03,
		0x33,  0x36,  0x38,  0x38,  0x35,  0x37,  0x35,  0x35,  0x2d,  0x64,
		0x37,  0x32,  0x66,  0x2d,  0x34,  0x30,  0x36,  0x31,  0x2d,  0x39,
		0x64,  0x31,  0x33,  0x2d,  0x38,  0x31,  0x38,  0x61,  0x35,  0x35,
		0x64,  0x66,  0x37,  0x39,  0x35,  0x66,  0x00,  0x01,  0x49,  0x03,
		0x30,  0x00,  0x01,  0x47,  0x03,  0x41,  0x72,  0x63,  0x68,  0x69,
		0x76,  0x65,  0x00,  0x01,  0x4a,  0x03,  0x31,  0x32,  0x00,  0x01,
		0x01,  0x4f,  0x48,  0x03,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,
		0x30,  0x30,  0x2d,  0x30,  0x30,  0x30,  0x30,  0x2d,  0x30,  0x30,
		0x30,  0x30,  0x2d,  0x30,  0x30,  0x30,  0x30,  0x2d,  0x30,  0x30,
		0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x34,
		0x00,  0x01,  0x49,  0x03,  0x30,  0x00,  0x01,  0x47,  0x03,  0x44,
		0x72,  0x61,  0x66,  0x74,  0x73,  0x00,  0x01,  0x4a,  0x03,  0x33,
		0x00,  0x01,  0x01,  0x4f,  0x48,  0x03,  0x30,  0x30,  0x30,  0x30,
		0x30,  0x30,  0x30,  0x30,  0x2d,  0x30,  0x30,  0x30,  0x30,  0x2d,
		0x30,  0x30,  0x30,  0x30,  0x2d,  0x30,  0x30,  0x30,  0x30,  0x2d,
		0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,
		0x30,  0x35,  0x00,  0x01,  0x49,  0x03,  0x30,  0x00,  0x01,  0x47,
		0x03,  0x4a,  0x75,  0x6e,  0x6b,  0x00,  0x01,  0x4a,  0x03,  0x31,
		0x32,  0x00,  0x01,  0x01,  0x4f,  0x48,  0x03,  0x30,  0x30,  0x30,
		0x30,  0x30,  0x30,  0x30,  0x30,  0x2d,  0x30,  0x30,  0x30,  0x30,
		0x2d,  0x30,  0x30,  0x30,  0x30,  0x2d,  0x30,  0x30,  0x30,  0x30,
		0x2d,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,
		0x30,  0x30,  0x33,  0x00,  0x01,  0x49,  0x03,  0x30,  0x00,  0x01,
		0x47,  0x03,  0x53,  0x65,  0x6e,  0x74,  0x00,  0x01,  0x4a,  0x03,
		0x35,  0x00,  0x01,  0x01,  0x4f,  0x48,  0x03,  0x30,  0x30,  0x30,
		0x30,  0x30,  0x30,  0x30,  0x30,  0x2d,  0x30,  0x30,  0x30,  0x30,
		0x2d,  0x30,  0x30,  0x30,  0x30,  0x2d,  0x30,  0x30,  0x30,  0x30,
		0x2d,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,  0x30,
		0x30,  0x30,  0x32,  0x00,  0x01,  0x49,  0x03,  0x30,  0x00,  0x01,
		0x47,  0x03,  0x54,  0x72,  0x61,  0x73,  0x68,  0x00,  0x01,  0x4a,
		0x03,  0x34,  0x00,  0x01,  0x01,  0x4f,  0x48,  0x03,  0x32,  0x3a,
		0x30,  0x00,  0x01,  0x49,  0x03,  0x30,  0x00,  0x01,  0x47,  0x03,
		0x43,  0x6f,  0x6e,  0x74,  0x61,  0x63,  0x74,  0x73,  0x00,  0x01,
		0x4a,  0x03,  0x39,  0x00,  0x01,  0x01,  0x4f,  0x48,  0x03,  0x33,
		0x3a,  0x41,  0x44,  0x65,  0x45,  0x5a,  0x4e,  0x64,  0x4b,  0x51,
		0x5a,  0x68,  0x4a,  0x73,  0x56,  0x42,  0x63,  0x72,  0x52,  0x70,
		0x30,  0x38,  0x61,  0x61,  0x4a,  0x54,  0x4a,  0x4e,  0x4b,  0x58,
		0x41,  0x31,  0x68,  0x51,  0x35,  0x5a,  0x5a,  0x52,  0x49,  0x79,
		0x36,  0x56,  0x54,  0x63,  0x4d,  0x00,  0x01,  0x49,  0x03,  0x30,
		0x00,  0x01,  0x47,  0x03,  0x41,  0x6c,  0x65,  0x78,  0x27,  0x73,
		0x20,  0x63,  0x61,  0x6c,  0x65,  0x6e,  0x64,  0x61,  0x72,  0x00,
		0x01,  0x4a,  0x03,  0x37,  0x00,  0x01,  0x01,  0x4f,  0x48,  0x03,
		0x31,  0x3a,  0x41,  0x44,  0x65,  0x45,  0x5a,  0x4e,  0x64,  0x4b,
		0x51,  0x5a,  0x68,  0x4a,  0x73,  0x56,  0x42,  0x63,  0x72,  0x52,
		0x70,  0x30,  0x38,  0x61,  0x61,  0x4a,  0x54,  0x4a,  0x4e,  0x4b,
		0x58,  0x41,  0x31,  0x68,  0x51,  0x35,  0x5a,  0x5a,  0x52,  0x49,
		0x79,  0x36,  0x56,  0x54,  0x63,  0x4d,  0x00,  0x01,  0x49,  0x03,
		0x30,  0x00,  0x01,  0x47,  0x03,  0x41,  0x6c,  0x65,  0x78,  0x27,
		0x73,  0x20,  0x63,  0x61,  0x6c,  0x65,  0x6e,  0x64,  0x61,  0x72,
		0x00,  0x01,  0x4a,  0x03,  0x38,  0x00,  0x01,  0x01,  0x01,  0x01
	};
	//string xml = wbxml2xml(string(binary, binary_size));
//	print_xml(xml.c_str(), xml.size(), "wbxml2xml(): ");

	//
	printf("\n\n > Using memory parser:\n");
	//
	if(0)
	{
		ParsingContext context;
		WBXMLParser * wbxml_parser = wbxml_parser_create();
		WBXMLContentHandler callback_structure = {
			& context.start_document,
			& context.end_document,
			& context.start_element,
			& context.end_element,
			& context.characters,
			& context.pi,
			NULL,
			NULL,
			NULL
		};
		wbxml_parser_set_user_data(wbxml_parser, &context);
		wbxml_parser_set_content_handler(wbxml_parser, &callback_structure);
		wbxml_parser_set_language(wbxml_parser, WBXML_LANG_ACTIVESYNC);
		WBXMLError ret = WBXML_OK;
		ret = wbxml_parser_parse(wbxml_parser, (unsigned char*) binary, binary_size);
	}



	//
	printf("\n\n > Using file parser:\n");
	//
	{
		ParsingContext context;
		WBXMLParser * wbxml_parser = wbxml_parser_create();
		WBXMLContentHandler callback_structure = {
			& context.start_document,
			& context.end_document,
			& context.start_element,
			& context.end_element,
			NULL, // this shall be NULL or every big chunk will be loaded into memory to satisfy this callback !
			& context.pi,
			& context.characters_in_filebuffer,
			& context.allocated_filename_provider,
			& context.free_allocated_filename
		};
		wbxml_parser_set_user_data(wbxml_parser, &context);
		wbxml_parser_set_content_handler(wbxml_parser, &callback_structure);
		wbxml_parser_set_language(wbxml_parser, WBXML_LANG_ACTIVESYNC);
		WBXMLError ret = WBXML_OK;
		ret = wbxml_parser_parse_file(wbxml_parser, "../foldersync_response.wbxml");
	}

	printf("Done. \n");
}
